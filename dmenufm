#!/bin/sh

# Dmenu-based directory browser
# Dependency: dmenu; xclip
# Dependency on extraction: tar; unlzma; bunzip2; unrar; unzip; uncompress; 7z; unxz; cabextract.


### OPTIONS AND VARIABLES

## OPTIONS
[ -n "$DMENUFM_PATH" ] || DMENUFM_PATH="$HOME/.config/dmenufm"
[ -n "$DMENUFM_TRASH_PATH" ] || DMENUFM_TRASH_PATH="$DMENUFM_PATH/trash"
[ -n "$DMENUFM_BMKFILE" ] || DMENUFM_BMKFILE="$DMENUFM_PATH/dmenufm_bookmark"
[ -n "$DMENUFM_CMDFILE" ] || DMENUFM_CMDFILE="$DMENUFM_PATH/dmenufm_command"
[ -n "$DMENUFM_HISFILE" ] || DMENUFM_HISFILE="$DMENUFM_PATH/dmenufm_history"
[ -n "$DMENUFM_LAST_PATH_FILE" ] || DMENUFM_LAST_PATH_FILE="$DMENUFM_PATH/dmenufm_lastpath"
[ -n "$DMENUFM_MAX_HIS_LENGTH" ] || DMENUFM_MAX_HIS_LENGTH=5000
XDGDIR1="/usr/share/applications"
XDGDIR2="/usr/local/share/applications"
# FONT
[ -n "$DMENUFM_GENERIC_FONT" ] || DMENUFM_GENERIC_FONT="Monospace-15"
[ -n "$DMENUFM_NOTIF_FONT" ] || DMENUFM_NOTIF_FONT="Monospace-25"
[ -n "$DMENUFM_DANGER_FONT" ] || DMENUFM_DANGER_FONT="Monospace-20"


## GLOBAL VARIABLES
CHOICE="placeholder"
actCHOICE="placeholder"
TARGET="./"
BACKWARD="../"
ENDSELECTION="End Selection"
allowmulti="NotAllowed"
ACTION="Actions"
TERM="Terminal"
FM_CP_PATH="PCP - Copy path"
FM_NEW="NEW - Create new file / directory"
FM_RM="RMM - Remove files / directory"
FM_MVR="MVR - Move files"
FM_CP="CPP - Copy files"
FM_TRASH="TRH - Trash of dmenufm"
FM_HIST="HIS - History of dmenufm"
FM_BMARK="BMK - Bookmark for dmenufm"
FM_COMMAND="CMD - Frequently used command"
ACTLIST="$FM_CP_PATH:$FM_NEW:$FM_MVR:$FM_CP:$FM_RM:$FM_TRASH:$FM_HIST:$FM_BMARK:$FM_COMMAND"



### FUNCTIONS


## OPEN FUNCTIONS

# You may need to modify executecmd to match how your terminal execute the command.
# Use `< $(locate $software.desktop | tail -n 1) grep "Terminal=false` to check whether the .desktop file should open in terminal
# Like sxiv, the desktop file don't have Terminal entry. You need to Use `< $(locate sxiv.desktop | tail -n 1) sudo $EDITOR` to add `Terminal=false`
executecmd () {
	software=$(printf '%s' "$1" | awk -F ' ' '{print $1}')
	if < "$(find "$XDGDIR1" "$XDGDIR2" *"$software"*.desktop | tail -n 1)" grep "Terminal=false"; then
		printf '%s' "$1" | ${SHELL:-"/bin/sh"}
	else
		$TERMINAL -e $1 | ${SHELL:-"/bin/sh"}
	fi
}

# Open files with xdg-open, if not compression.
# Compressions are extracted by its file extension.
# Use extraction to put content in a new directory.
# To edit default applications in xdg-open,
# sudo $EDITOR /usr/share/applications/mimeinfo.cache
open () {
case "$1" in
	*.tar.bz2|*.tar.xz|*.tbz2) extraction "tar xvjf" "$1" ;;
	*.tar.gz|*.tgz) extraction "tar xvzf" "$1" ;;
	*.lzma) extraction "unlzma" "$1" ;;
	*.bz2) extraction "bunzip2" "$1" ;;
	*.rar) extraction "unrar x -ad" "$1" ;;
	*.gz) extraction "gunzip" "$1" ;;
	*.tar) extraction "tar xvf" "$1" ;;
	*.zip) extraction "unzip" "$1" ;;
	*.Z) extraction "uncompress" "$1" ;;
	*.7z) extraction "7z x" "$1" ;;
	*.xz) extraction "unxz" "$1" ;;
	*.exe) extraction "cabextract" "$1" ;;
	*)
		appdesktop=$(xdg-mime query filetype "$1" | xargs -I {} xdg-mime query default "{}")
		if < "$(find "$XDGDIR1" "$XDGDIR2" -name "$appdesktop" | tail -n 1)" grep "Terminal=false"; then
			xdg-open "$1"
		else
			$TERMINAL -e xdg-open "$1"
		fi
		;;
esac
}


## MENUFUNCTIONS

# Generate directories
# Variables cannot store multiline string, so transform to ':'
# Misbehaving due to space in file/directory name, so add ' at beginning and end.
menudir () {
	DIRs=$(for dir in *; do [ -d "$dir" ] && printf '%s:' "$dir/"; done | sed "1 s/^/'/; s/$/'/")
}

# Generate dotdirectories
# Delete extra ./ and ../ (Need use = as sed delimiter)
menudotdir () {
	DOTDIRs=$(for dir in .*; do [ -d "$dir" ] && printf '%s:' "$dir/"; done | sed "1 s/^/'/; s/$/'/; s=./==; s=../==")
}

# Generate files
menufile () {
	FILEs=$(for file in *; do [ -f "$file" ] && printf '%s:' "$file"; done | sed "1 s/^/'/; s/$/'/")
}

# Generate dotfiles
menudotfile () {
	DOTFILEs=$(for file in .*; do [ -f "$file" ] && printf '%s:' "$file"; done | sed "1 s/^/'/; s/$/'/")
}

# Generate default menu
menu () {
	menudir
	menudotdir
	menufile
	menudotfile
}

# Update menu in each move
update_menu () {
	list=
	# Rebuild list in every move
	for element in $keeplist; do
		case $element in
			DIRs) menudir && list="$list$DIRs" ;;
			FILEs) menufile && list="$list$FILEs" ;;
			DOTDIRs) menudotdir && list="$list$DOTDIRs" ;;
			DOTFILEs) menudotfile && list="$list$DOTFILEs" ;;
		esac
	done
}

# Generate menu for action choice, only for current directory.
# $1 is the prompt, $2 is the selected background color
Generate_action_menu () {
	while [ -n "$actCHOICE" ]; do
		update_menu
		# Default menu list if no arguments given
		[ -z "$keeplist" ] && menu && list="$DIRs$FILEs$DOTDIRs$DOTFILEs"
		# Generate menu with/without arguments
		# Show only the current directory and one level of parent directory
		twopwd=$(printf '%s' "$PWD" | awk -F '/' '{print $(NF-1)"/"$NF}')
		if [ -n "$multiselection" ]; then
			actCHOICE=$(printf '%s:' "$BACKWARD" "$TARGET" "$ENDSELECTION" "$list" | tr ':' '\n' | sed "s/'//g; /^$/ d" | verticalprompt "$1" "$2")
		else
			if [ "$allowmulti" != "NotAllowed" ]; then
				actCHOICE=$(printf '%s:' "$BACKWARD" "$TARGET" "$allowmulti" "$list" | tr ':' '\n' | sed "s/'//g; /^$/ d" | verticalprompt "$1" "$2")
			else
				actCHOICE=$(printf '%s:' "$BACKWARD" "$TARGET" "$list" | tr ':' '\n' | sed "s/'//g; /^$/ d" | verticalprompt "$1" "$2")
			fi
		fi
		# Outcome matching
		if [ "$actCHOICE" = "$TARGET" ]; then
			HERE=$(printf '%s' "$PWD")
			name=$(printf '%s' "$HERE" | awk -F '/' '{print $NF}')
			[ -n "$multiselection" ] && multilist="$multilist:$HERE" && cd "../"
			break
		elif [ "$actCHOICE" = "$BACKWARD" ]; then
			cd "../" || return
			dmenufm_history
		elif [ "$actCHOICE" = "$ENDSELECTION" ]; then
			multiselection=
			break
		elif [ "$actCHOICE" = "$allowmulti" ]; then
			multiselection="true"
			break
		elif [ -d "$actCHOICE" ]; then
			cd "$actCHOICE" || exit 1
			dmenufm_history
			continue
		elif [ -f "$actCHOICE" ] || [ -n "$rename" ]; then
			HERE=$(printf '%s' "$PWD/$actCHOICE")
			name=$(printf '%s' "$HERE" | awk -F '/' '{print $NF}')
			[ -n "$multiselection" ] && multilist="$multilist:$HERE"
			break
		else
			HERE=
			name=
			multiselection=
			actCHOICE="placeholder"
			break
		fi
	done
}

## PROMPT FUNCTIONS
verticalprompt () {
	# $1 is prompt
	dmenu -fn "$DMENUFM_GENERIC_FONT" -i -sb "$2" -l 10 -p "$1"
}

horizontalprompt () {
	# $1 is prompt
	dmenu -fn "$DMENUFM_GENERIC_FONT" -i -sb "$2" -p "$1" <&-
}

notifyprompt () {
	dmenu -fn "$DMENUFM_NOTIF_FONT" -sb "#d79921" -sf "#1d2021" -nf "#000000" -nb "#000000" -p "$1" <&-
}

# Prompt that used in dangerous action
dangerprompt () {
	# From Luke Smith
	# Use && command to execute the command after "Yes"
	[ "$(printf "No\\nYes" | dmenu -fn "$DMENUFM_DANGER_FONT" -i -p "$1" -nb darkred -sb red -sf white -nf gray )" = "Yes" ]
}


## TOOL FUNCTIONS

# Exit actions when press ESC in menu
escape () {
	[ -n "$1" ] || return
}

# Store every move between directories into history
dmenufm_history () {
	[ ! -d "$DMENUFM_PATH" ] && mkdir -p "$DMENUFM_PATH"
	dirmark=$(printf '%s' "$PWD" | awk -F '/' '{print $NF}')
	printf '%s\n' "$dirmark - $PWD" | sed "/^$/ d" >> "$DMENUFM_HISFILE"
	# Limit the max number of history
	hisnum=$(wc -l "$DMENUFM_HISFILE" | awk '{print $1}')
	if [ "$hisnum" -ge "$DMENUFM_MAX_HIS_LENGTH" ]; then
		sed "1d" "$DMENUFM_HISFILE" > "$DMENUFM_HISFILE.backup" && cp "$DMENUFM_HISFILE.backup" "$DMENUFM_HISFILE"
	fi
}

# Extract files and make a new directory to contain all the files.
extraction () {
	# $1: command to extract compress
	# $2: compression name
	# Example: extraction "unzip" "$HOME/filename.zip"
	dirname="$(printf '%s' "$2" | awk -F '/' '{printf $NF}' | awk -F '.' '{print $1}')"
	mkdir -p "$dirname" && cd "$dirname" || exit
	$1 "$2"
	notifyprompt "$CHOICE extracted to $dirname"
}

dmenufm_multiselect () {
	# $1 for the action to run
	# $2 for the prompt when multi selecting
	# $3 for notification
	# $4 for prompt if it is dangerous
	actioncmd=$1
	multiprompt=$2
	notifymessage=$3
	dangerousmessage=$4
	HERE=
	multilist=
	Generate_action_menu "$multiprompt" "#33691e" || return && allowmulti="NotAllowed"
	while [ -n "$multiselection" ]; do
		Generate_action_menu "$multiprompt" "#33691e" || return && allowmulti="NotAllowed"
		HERE=$multilist
		allowmulti="NotAllowed"
	done

	HERE=$(printf '%s' "$HERE" | cut -b2- | tr ':' '\n' | uniq)
	allowmulti="NotAllowed"

	[ "$actCHOICE" = "$ENDSELECTION" ] && printf '%s' "$HERE" | verticalprompt "Selected files (Enter to continue): " "#33691e"

	[ "$actCHOICE" = "$ENDSELECTION" ] && [ -n "$dangerousmessage" ] && dangerprompt "$dangerousmessage" || return
	case $actioncmd in
		"RMM")
			for selection in $(printf '%s' "$HERE"); do
				rm -rf "$selection"
			done && [ -n "$notifymessage" ] && notifyprompt "$notifymessage"
			;;
		"TRH")
			for selection in $(printf '%s' "$HERE"); do
				mv "$selection" "$DMENUFM_TRASH_PATH"
			done && [ -n "$notifymessage" ] && notifyprompt "$notifymessage"
			;;
		*)
			return
			;;
	esac
}

# Actions that for dmenufm
# Note: Use `[ -n "$VAR" ]` after each menu to check whether the menu is correctly execute.
# 	If not, then the later command will not execute.
dmenufm_action (){
	move=$(printf '%s' "$ACTLIST" | tr ':' '\n' | verticalprompt "Actions:" "#005577")
	case $move in
		"$FM_CP_PATH")
			# Copy path to xclip, and send notification.
			Generate_action_menu "Copy directory/file path: " "#33691e" || return
			[ -n "$HERE" ] && printf '%s' "$HERE" | xclip -selection clipboard && notifyprompt "Path $name copied to clipboard."
			;;
		"$FM_NEW")
			name=$(horizontalprompt "Dir ends w/ slash; File w/o: " "#33691e") || return
			if [ -n "$( printf "$name" | grep '/')" ]; then
				mkdir -p "$name" && notifyprompt "Directory $name created."
			else
				:>"$name" && notifyprompt "File $name created."
			fi
			;;
		"$FM_MVR"|"$FM_CP")
			cmd="mv" && cmdname="moved"
			[ "$move" = "$FM_CP" ] && cmd="cp" && cmdname="copied"
			Generate_action_menu "Source: " "#33691e" || return
			[ -n "$HERE" ] && start="$HERE" && startname="$name" && rename="true"
			[ -d "$start" ] && cd "../"
			[ -n "$start" ] && Generate_action_menu "Destination / Type new name: " "#FF8C00" || return && rename=
			[ -n "$HERE" ] && destination="$HERE" && destname="$name"
			[ -n "$HERE" ] && $cmd "$start" "$destination" && notifyprompt "$startname $cmdname to $destname"
			rename=
			;;
		"$FM_RM")
			# Allow multiple files to be selected
			allowmulti="Bulk Remove"
			# Choose file/directory in current directory to remove
			Generate_action_menu "Remove file / directory: " "#33691e" || return && allowmulti="NotAllowed"
			if [ -n "$multiselection" ]; then
				dmenufm_multiselect "RMM" "Select files / directories " "Selected files deleted" "Are you sure you would like to delete all selected files?"
			else
			allowmulti="NotAllowed"
			# Check the chosen on is directory or not
				[ -n "$HERE" ] && [ -d "$HERE" ] && result=$?
				if [ -n "$HERE" ] && dangerprompt "Remove all files and/or subdirectories in $name?" && rm -rf "$HERE"; then
					# If chosen one is directory, send notification and cd to parent directory
					if [ "$result" = "0" ]; then
						notifyprompt "$name removed." || return
						cd "../" || return
						# Reset result value
						result=
					else
						# If not, just send notification.
						notifyprompt "$name removed." || return
					fi
				else
					return
				fi
			fi
			;;
		"$FM_TRASH")
			# Allow multiple files to be selected
			allowmulti="Bulk Trash"
			[ ! -d "$DMENUFM_TRASH_PATH" ] && mkdir -p "$DMENUFM_TRASH_PATH"
			trashmenu=$(printf '%s\n' "Move to trash" "Go to trash" "Empty trash" | sed "/^$/ d" | verticalprompt "Dmenufm Trash" "#005577")
			case $trashmenu in
				"Move to trash")
					Generate_action_menu "Move file/directory to trash: " "#33691e" || return && allowmulti="NotAllowed"
					if [ -n "$multiselection" ]; then
						dmenufm_multiselect "TRH" "Select files / directories " "Selected files moved to trash" "Are you sure you would like to move all selected files to trash?"
					else
						allowmulti="NotAllowed"
						# Check the chosen on is directory or not
						[ -n "$HERE" ] && [ -d "$HERE" ] && result=$?
						# Say yes in dangerprompt, and send notification. Or do nothing.
						if [ -n "$HERE" ] && dangerprompt "Move all files and/or subdirectories in $name to trash?" && mv "$HERE" "$DMENUFM_TRASH_PATH"; then
							if [ $result -eq 0 ]; then
								notifyprompt "$name moved to trash." || return
								cd "../" || return
								result=
							else
								notifyprompt "$name moved to trash." || return
							fi
						else
							return
						fi
					fi
					;;
				"Go to trash")
					cd "$DMENUFM_TRASH_PATH" || return
					;;
				"Empty trash")
					# Lesson: You cannot quote a wildcard. No quote on *.
					if dangerprompt "Remove all files and/or directory in trash?" && rm -rf "$DMENUFM_TRASH_PATH"/*; then
						notifyprompt "Trash is empty." || return
					else
						return
					fi
					;;
			esac
			;;
		"$FM_HIST")
			# Use sed command to mimic reverse of cat for POSIX.
			goto=$(sed '1!G;h;$!d' "$DMENUFM_HISFILE" | verticalprompt "Dmenufm History" "#005577")
			destination=$(printf '%s' "$goto" | awk -F ' - ' '{print $2}')
			cd "$destination" || return
			;;
		"$FM_BMARK")
			markmenu=$(printf '%s\n' "$(cat "$DMENUFM_BMKFILE")" "Add BMK" "Delete BMK" | sed "/^$/ d" |  verticalprompt "Dmenufm Bookmark" "#005577")
			case "$markmenu" in
				"Add BMK")
					Generate_action_menu "Choose file/directory and add to BMK: " "#33691e" || return
					mark=$(printf '%s' "$HERE" | awk -F '/' '{print $NF}')
					[ -n "$mark" ] && printf '%s\n' "$mark - $HERE" >> "$DMENUFM_BMKFILE"
					[ -n "$mark" ] && sed "/^$/ d" "$DMENUFM_BMKFILE" >  "$DMENUFM_BMKFILE.backup" && cp "$DMENUFM_BMKFILE.backup" "$DMENUFM_BMKFILE"
					;;
				"Delete BMK")
					delbmk=$(< "$DMENUFM_BMKFILE" verticalprompt "Delete chosen bmk: " "darkred") || return
					# POSIX way of sed -i.
					# Assign address as '=' by '\=pattern='
					# Create backup file and cp to original file.
					[ -n "$delbmk" ] && sed "\=$delbmk= d" "$DMENUFM_BMKFILE" > "$DMENUFM_BMKFILE.backup" && cp "$DMENUFM_BMKFILE.backup" "$DMENUFM_BMKFILE"
					;;
				*)
					destination=$(printf '%s' "$markmenu" | awk -F ' - ' '{print $2}')
					if [ -n "$destination" ]; then
						cd "$destination" || open "$destination"
					fi
			esac
			;;
		"$FM_COMMAND")
			cmdmenu=$(printf '%s\n' "$(cat "$DMENUFM_CMDFILE")" "Add CMD" "Delete CMD" "Type and execute" | sed "/^$/ d" | verticalprompt "Dmenufm Custom Command" "#005577")
			case "$cmdmenu" in
				"Add CMD")
					addcmd=$(horizontalprompt "Recording your command: " "#33691e") || return
					desp=$(horizontalprompt "Enter command description: " "#33691e") || return
					[ -n "$addcmd" ] && printf '%s\n' "$addcmd - $desp" >> "$DMENUFM_CMDFILE"
					[ -n "$addcmd" ] && sed "/^$/ d" "$DMENUFM_CMDFILE" >  "$DMENUFM_CMDFILE.backup" && cp "$DMENUFM_CMDFILE.backup" "$DMENUFM_CMDFILE"
					;;
				"Delete CMD")
					delcmd=$(< "$DMENUFM_CMDFILE" verticalprompt "Delete chosen command: " "darkred")
					# POSIX way of sed -i.
					# Assign address as '+' by '\+pattern+'
					# '=' seems not usable in command
					# Create backup file and cp to original file.
					[ -n "$delcmd" ] && sed "\+$delcmd+ d" "$DMENUFM_CMDFILE" > "$DMENUFM_CMDFILE.backup" && cp "$DMENUFM_CMDFILE.backup" "$DMENUFM_CMDFILE"
					;;
				"Type and execute")
					execmd=$(horizontalprompt "Type and execute: " "#33691e")
					[ -n "$execmd" ] && executecmd "$execmd"
					;;
				*)
					execmd=$(printf '%s' "$cmdmenu" | awk -F ' - ' '{print $1}')
					executecmd "$execmd"
					;;
			esac
			;;
	esac
	dmenufm_menu
}

### MAIN FUNCTIONS

dmenufm_menu () {
	while [ -n "$CHOICE" ]; do
		update_menu
		# Default menu list if no arguments given
		[ -z "$keeplist" ] && menu && list="$DIRs$FILEs$DOTDIRs$DOTFILEs"
		# Generate menu with/without arguments
		# Show only the current directory and one level of parent directory
		twopwd=$(printf '%s' "$PWD" | awk -F '/' '{print $(NF-1)"/"$NF}')
		CHOICE=$(printf '%s:' "$BACKWARD" "$TARGET" "$ACTION" "$TERM" "$list" | tr ':' '\n' | sed "s/'//g; /^$/ d" | verticalprompt "$twopwd" "#005577")
		# Outcome matching
		if [ "$CHOICE" = "$TARGET" ]; then
			open "$PWD"
		elif [ "$CHOICE" = "$BACKWARD" ]; then
			cd "../"
			dmenufm_history
		elif [ "$CHOICE" = "$ACTION" ]; then
			dmenufm_action
		elif [ "$CHOICE" = "$TERM" ]; then
			$TERMINAL
		elif [ -d "$CHOICE" ]; then
			cd "$CHOICE" || exit 1
			dmenufm_history
			continue
		elif [ -f "$CHOICE" ]; then
			open "$PWD/$CHOICE"
		else
			break
		fi
	done
}

### ARGUMENTS

while [ -n "$1" ]; do
	case $1 in
		"-d"|"--directory" )
			keeplist="${keeplist} DIRs"
			;;
		"-f"|"--file" )
			keeplist="${keeplist} FILEs"
			;;
		"-D"|"--dotdirectory" )
			keeplist="${keeplist} DOTDIRs"
			;;
		"-F"|"--dotfile" )
			keeplist="${keeplist} DOTFILEs"
			;;
		"-p"|"--lastpath" )
			outputpath="placeholder"
			;;
		"-h"|"--help" )
			printf " Optional arguments for custom usage:
			-d | --directory: only directories
			-f | --file: only show files
			-D | --dotdirectory: only show hidden directories
			-F | --dotfile: only show hidden files
			-p | --lastpath: opens in last working directory (cd on exit)
			-h | --help: Show this message\\n"
			exit 0
			;;
		"*" )
			printf "Invalid option"
			exit 1
			;;
	esac
	shift
done

### RUN THE MAIN FUNCTION

# --lastpath option:
[ -n "$outputpath" ] && cd "$(cat "$DMENUFM_LAST_PATH_FILE")"

dmenufm_menu

printf '%s' "$PWD" > "$DMENUFM_LAST_PATH_FILE"
