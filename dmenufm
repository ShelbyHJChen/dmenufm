#!/bin/sh

# Dmenu-based directory browser
# Dependency: dmenu; xclip
# Dependency on extraction: tar; unlzma; bunzip2; unrar;
# 			    unzip; uncompress; 7z; unxz; cabextract.

### OPTIONS AND VARIABLES

## OPTIONS
# FILES LOCATION
[ -n "$FM_PATH" ] || FM_PATH="$HOME/.config/dmenufm"
[ -n "$FM_TRASH" ] || FM_TRASH="$FM_PATH/trash"
[ -n "$FM_BMKFILE" ] || FM_BMKFILE="$FM_PATH/dmenufm_bookmark"
[ -n "$FM_CMDFILE" ] || FM_CMDFILE="$FM_PATH/dmenufm_command"
[ -n "$FM_HISFILE" ] || FM_HISFILE="$FM_PATH/dmenufm_history"
[ -n "$FM_LASTPATH" ] || FM_LASTPATH="$FM_PATH/dmenufm_lastpath"
[ -n "$FM_REMFILE" ] || FM_REMFILE="$FM_PATH/dmenufm_bulk_rename"
[ -n "$FM_ZIPATH" ] || FM_ZIPATH="$FM_PATH/compression/"
# Max number for history
[ -n "$FM_MAX_HIS_LENGTH" ] || FM_MAX_HIS_LENGTH=5000
# FONTS
[ -n "$FM_GENERIC_FONT" ] || FM_GENERIC_FONT="Monospace-15"
[ -n "$FM_NOTIF_FONT" ] || FM_NOTIF_FONT="Monospace-25"
[ -n "$FM_DANGER_FONT" ] || FM_DANGER_FONT="Monospace-20"
# COLORs
[ -n "$FM_GENERIC_COLOR" ] || FM_GENERIC_COLOR="#005577"
[ -n "$FM_ACTION_COLOR_LV1" ] || FM_ACTION_COLOR_LV1="#33691e"
[ -n "$FM_ACTION_COLOR_LV2" ] || FM_ACTION_COLOR_LV2="#FF8C00" [ -n "$FM_ACTION_COLOR_BULK" ] || FM_ACTION_COLOR_BULK="#CB06CB"

# xdg-open directories
XDGDIR1="/usr/share/applications"
XDGDIR2="/usr/local/share/applications"

## GLOBAL VARIABLES
CHOICE="placeholder"
actCHOICE="placeholder"
allselection="placeholder"
TARGET="./"
BACKWARD="../"
ENDSELECTION="End Selection"
allowbulk="NotAllowed"
ACTION="Actions"
TERM="Terminal"
FM_PCP="PCP - Copy path"
FM_NEW="NEW - Create new file / directory"
FM_DEL="DEL - Delete files / directories"
FM_MVV="MVV - Move files / directories"
FM_YAK="YAK - Copy files / directories"
FM_LNK="LNK - Symbolically link files / directories"
FM_REM="REM - Rename files / directories"
FM_TRH="TRH - Trash of dmenufm"
FM_HIS="HIS - History of dmenufm"
FM_BMK="BMK - Bookmark for dmenufm"
FM_CMD="CMD - Frequently used command"
FM_ZIP="ZIP - Compress files / directories"
ACTLIST=$(printf '%s\n' "$FM_PCP" "$FM_NEW" "$FM_MVV" "$FM_YAK" "$FM_LNK" "$FM_DEL" "$FM_TRH" "$FM_REM" "$FM_HIS" "$FM_BMK" "$FM_CMD" "$FM_ZIP")
COMPRESSIONLIST=$(printf '%s\n' "tar.gz" "tar.bz2" "tar.xz" "xz" "lzma" "gz" "bz2" "7z" "zip")

### FUNCTIONS

## PRE-DETERMINATION FUNCTION

# Check dependencies

CheckDeps () {
	for CurDep in "$@"; do
		if ! command -v "$CurDep" 1> /dev/null 2>&1; then
			printf "ERROR: Dependency $CurDep not met."  1>&2
		fi
	done

	unset CurDep
}

CheckDeps find tail xdg-mime xdg-open sed awk grep wc cp mv rm paste


# # Check os
# get_os () {
# 	case $OSTYPE in
# 		# Mac OS X / macOS.
# 		darwin*) FM_OPENER=open ;;
# 	esac
# }

## OPEN FUNCTIONS

# See README.md for more detail

ExecCMD () { # Usage ExecCMD [CMD]
	software=$(printf '%s' "${1%% *}")
	appdesktop=$(find "$XDGDIR1" "$XDGDIR2" -name "*$software*.desktop" | tail -n 1)
	if [ -n "$appdesktop" ] && grep 'Terminal=false' "$appdesktop"; then
		printf '%s' "$1" | ${SHELL:-"/bin/sh"}
	else
		$TERMINAL -e $1 | ${SHELL:-"/bin/sh"}
	fi
}

# Open files with xdg-open, if not compression.
# Compressions are extracted by its file extension.
# Use Extract to put content in a new directory.
# To edit default applications in xdg-open,
# sudo $EDITOR /usr/share/applications/mimeinfo.cache

Extract () { # Usage: Extract [CMD] [FILE]
	BaseName=${2##*/}
	DirName=${BaseName%%.*}

	CheckDeps "${1%% *}" || exit 1
	[ ! -d "DirName" ] && mkdir -p "$DirName"
	cd "$DirName"
	$1 "$2"
	NotiPrompt "$Choice extracted to $BaseName"
}

FileOpen () {
	mimetype=$(xdg-mime query filetype "$1")
	case "$1" in
		*.tar.bz2|*.tar.xz|*.tbz2) Extract "tar xvjf" "$1" ;;
		*.tar.gz|*.tgz) Extract "tar xvzf" "$1" ;;
		*.lzma) Extract "unlzma" "$1" ;;
		*.bz2) Extract "bunzip2" "$1" ;;
		*.rar) Extract "unrar x -ad" "$1" ;;
		*.gz) Extract "gunzip" "$1" ;;
		*.tar) Extract "tar xvf" "$1" ;;
		*.zip) Extract "unzip" "$1" ;;
		*.Z) Extract "uncompress" "$1" ;;
		*.7z) Extract "7z x" "$1" ;;
		*.xz) Extract "unxz" "$1" ;;
		*.cab) Extract "cabextract" "$1" ;;
		*)
			case "$mimetype" in
				text/*|*x-empty*|*json*)
					# Text file opened in $EDITOR or default opener
					if [ -n "$TERMINAL" ]; then
						$TERMINAL -e ${EDITOR:-vi} "$1"
					else
						${FM_OPENER:-xdg-open} "$1"
					fi
					;;
				*)
					appdesktop=$(xdg-mime query default "$mimetype")
					if < "$(find "$XDGDIR1" "$XDGDIR2" -name "$appdesktop" \
						| tail -n 1)" grep "Terminal=false"; then
						${FM_OPENER:-xdg-open} "$1"
					else
						$TERMINAL -e ${FM_OPENER:-xdg-open} "$1"
					fi
					;;
			esac
	esac
}


## MENUFUNCTIONS

# Generate directories
MenuDir () {
	IFS="
	"
	DIRs=$(
		for dir in *; do
			[ -d "$dir" ] && printf '%s\n' "$dir/"
		done
	)
	unset IFS
}

# Generate dotdirectories
# Delete extra ./ and ../ (Need use = as sed delimiter)
MenuDotDir () {
	IFS="
	"
	DOTDIRs=$(
		for dir in .*; do
			[ -d "$dir" ] && printf '%s\n' "$dir/"
		done | sed "\|^./$| d; \|^../$| d"
	)
	unset IFS
}

# Generate files
MenuFile () {
	IFS="
	"
	FILEs=$(
		for file in *; do
			[ -f "$file" ] && printf '%s\n' "$file"
		done
	)
	unset IFS
}

# Generate dotfiles
MenuDotFile () {
	IFS="
	"
	DOTFILEs=$(
		for file in .*; do
			[ -f "$file" ] && printf '%s\n' "$file"
		done
	)
	unset IFS
}

# Generate default menu
Menu () {
	MenuDir
	MenuDotDir
	MenuFile
	MenuDotFile
}

# Update menu in each move
UpdateMenu () {
	list=
	# Rebuild list in every move
	for element in $keeplist; do
		case $element in
			DIRs) MenuDir && list=$(printf '%s\n' "$list" "$DIRs") ;;
			FILEs) MenuFile && list=$(printf '%s\n' "$list" "$FILEs") ;;
			DOTDIRs) MenuDotDir && list=$(printf '%s\n' "$list" "$DOTDIRs") ;;
			DOTFILEs) MenuDotFile && list=$(printf '%s\n' "$list" "$DOTFILEs") ;;
		esac
	done
}

ActionMenu () { # Usage: ActionMenu [MSG] [BG_COLOR]
	while [ -n "$actCHOICE" ]; do
		UpdateMenu # Default menu list if no arguments given
		[ -z "$keeplist" ] && Menu \
			&& list=$(printf '%s\n' "$DIRs" "$FILEs" "$DOTDIRs" "$DOTFILEs")
		if [ "$rollingmenu" = "true" ] && [ -f "$actCHOICE" ]; then
			list=$(printf '%s\n' "$actCHOICE" "${list##*$actCHOICE}" "${list%%$actCHOICE*}" | sed "/^$/ d")
		fi
		if [ -n "$bulkselection" ]; then
			actCHOICE=$(printf '%s\n' "$BACKWARD" "$TARGET" \
				"$ENDSELECTION" "$list" \
				| sed "/^$/ d" \
				| yprompt "$1" "$2")
		elif [ "$allowbulk" != "NotAllowed" ]; then
			actCHOICE=$(printf '%s\n' "$BACKWARD" "$TARGET" \
				"$allowbulk" "$allselection" "$list" \
				| sed "/^$/ d" \
				| yprompt "$1" "$2")
		else
			actCHOICE=$(printf '%s\n' "$BACKWARD" "$TARGET" "$list" \
				| sed "/^$/ d" \
				| yprompt "$1" "$2")
		fi
		# Outcome matching
		if [ "$actCHOICE" = "$TARGET" ]; then
			if [ "$termpath" = "true" ]; then
				printf "$PWD" && actCHOICE=""
				break
			else
				HERE=$(printf '%s' "$PWD")
				name=$(printf '%s' "${PWD##*/}")
				[ -n "$bulkselection" ] \
					&& bulklist=$(printf '%s\n' "$bulklist" "$HERE") \
					&& cd "../"
				break
			fi
		elif [ "$actCHOICE" = "$BACKWARD" ]; then
			cd "../" || return
			History
		elif [ "$actCHOICE" = "$ENDSELECTION" ]; then
			bulkselection=
			break
		elif [ "$actCHOICE" = "$allowbulk" ]; then
			bulkselection="true"
			break
		elif [ "$actCHOICE" = "$allselection" ]; then
			bulkselection=
			HERE=$(printf '%s' "$PWD")
			name=$(printf '%s' "${PWD##*/}")
			break
		elif [ -d "$actCHOICE" ]; then
			cd "$actCHOICE" || exit 1
			History
			continue
		elif [ -f "$actCHOICE" ]; then
			if [ "$termpath" = "true" ]; then
				printf "$PWD/$actCHOICE" && actCHOICE=""
				break
			else
				HERE=$(printf '%s' "$PWD/$actCHOICE")
				name=$(printf '%s' "${PWD##*/}")
				[ -n "$bulkselection" ] \
					&& bulklist=$(printf '%s\n' "$bulklist" "$HERE")
				break
			fi
		else
			HERE=
			name=
			bulkselection=
			actCHOICE="placeholder"
			break
		fi
	done
}

## PROMPT FUNCTIONS
yprompt () { # Usage yprompt [MSG] [BG_COLOR]
	# $1 is prompt
	dmenu -fn "$FM_GENERIC_FONT" -i -sb "$2" -l 10 -p "$1"
}

xprompt () { # Usage xprompt [MSG] [BG_COLOR]
	# $1 is prompt
	dmenu -fn "$FM_GENERIC_FONT" -i -sb "$2" -p "$1" <&-
}

NotiPrompt () { # Usage NotiPrompt [MSG]
	dmenu -fn "$FM_NOTIF_FONT" -sb "#d79921" -sf "#1d2021" \
		-nf "#000000" -nb "#000000" -p "$1" <&-
}

DangerPrompt () { # Usage: DangerPrompt [MSG] && ...
	[ "$(printf "No\\nYes" \
		| dmenu -fn "$FM_DANGER_FONT" -i -p "$1" \
		-nb darkred -sb red -sf white -nf gray )" = "Yes" ]
}


## TOOL FUNCTIONS


BulkListAll () {
	SELECTED=$(printf '%s' "$list" \
		| sed "/^$/ d; s=^=$PWD/=g")
	[ -n "$SELECTED" ] \
		&& printf '%s' "$SELECTED" \
		| yprompt "Selected files (Enter to continue): " "$FM_ACTION_COLOR_LV1"
}

# Store every move between directories into history
History () {
	[ ! -d "$FM_PATH" ] \
		&& mkdir -p "$FM_PATH"
	dirmark="${PWD##*/}"
	printf '%s\n' "$dirmark - $PWD" \
		| sed "/^$/ d" >> "$FM_HISFILE"
	# Limit the max number of history
	TMP=$(wc -l "$FM_HISFILE")
	hisnum=${TMP%% *}
	unset TMP
	[ "$hisnum" -ge "$FM_MAX_HIS_LENGTH" ] \
		&& sed "1d" "$FM_HISFILE" > "$FM_HISFILE.backup" \
		&& cp "$FM_HISFILE.backup" "$FM_HISFILE"
}

# Bulk compression

BulkCompress () {
	case $compression_type in
		"tar.gz") cmd="tar -czvf" ;;
		"tar.xz") cmd="tar -cJvf" ;;
		"tar.bz2") cmd="tar -cjvf" ;;
		"gz") cmd="gzip -k" ;;
		"bz2") cmd="bzip2 -k" ;;
		"xz") cmd="xz -k" ;;
		"lzma") cmd="lzma -k" ;;
		"7z") cmd="7z a" ;;
		"zip") cmd="zip -r" ;;
		*) return ;;
	esac
	if echo "$compression_type" | grep -E '^tar|^zip'; then
		[ -d "$FM_ZIPATH" ] && rm -rf "$FM_ZIPATH"
		mkdir "$FM_ZIPATH"
		IFS="
		"
		for file in $SELECTED; do
			unset IFS
			cp -R "$file" "$FM_ZIPATH"
		done
		archive_name=$(xprompt "Please insert archive name: " "$FM_ACTION_COLOR_LV2" \
			| cut -d'.' -f1) || return
		if [ -n "$archive_name" ]; then
			compressdir_name="$archive_name"
			archive_name="$archive_name.$compression_type"
			mv "$FM_ZIPATH" "./$compressdir_name"
			$cmd $archive_name ./$compressdir_name/* \
				&& NotiPrompt "Compressed to $archive_name"
			rm -rf ./$compressdir_name
		fi
	else
		IFS="
		"
		for file in $SELECTED; do
			unset IFS
			$cmd "$file" \
				&& NotiPrompt "Compressed to ${file##*/}"
		done
	fi
	## TODO: Add error handling
}


# Bulk rename function.
# No argument

BulkRename () {
	if [ -n "$SELECTED" ]; then
		printf '%s\n' "$SELECTED" \
			| sed "s=/$==g" \
			> "$FM_REMFILE.backup"
		awk -F '/' '{print $NF}' "$FM_REMFILE.backup" \
			> "$FM_REMFILE"
		awk -F '/' '{$NF=""; print $0}' "$FM_REMFILE.backup" \
			| tr ' ' '/' \
			> "$FM_REMFILE.dirname"
		FileOpen "$FM_REMFILE"
		if [ $(wc -l < "$FM_REMFILE" ) -ne $(wc -l < "$FM_REMFILE.backup") ]; then
			NotiPrompt "ERROR: Lines mismatch in rename file; do nothing." \
				&& return
		else
			renamevar=$(paste -d ':' \
				"$FM_REMFILE.backup" \
				"$FM_REMFILE.dirname" \
				"$FM_REMFILE")
			# Set IFS for for loop as \n
			IFS="
			"
			for selection in $(printf '%s' "$renamevar"); do
				start=$(printf '%s' "$selection" \
					| awk -F ':' '{print $1}')
				destination=$(printf '%s' "$selection" \
					| awk -F ':' '{print $2$3}')
				if [ "$start" = "$destination" ]; then
					continue
				else
					mv "$start" "$destination"
				fi
			done && NotiPrompt "Selected renamed"
			unset IFS
		fi
	else
		return
	fi
}

BulkCMD () {
	execfile=$(printf '%s' "$SELECTED")
	execmd=$(printf '%s' "$execmd" | sed "1 s/$.*//")
	IFS="
	"
	for selection in $(printf '%s' "$execfile"); do
		unset IFS
		$execmd "$selection"
	done && NotiPrompt "Command executed on selected."
}

DestMenu () {
	ActionMenu "Destination: " \
		"$FM_ACTION_COLOR_LV2" \
		|| return \
		&& allowbulk="NotAllowed" \
		&& actCHOICE="placeholder"
	[ -n "$HERE" ] \
		&& destination="$HERE" \
		&& destname="$name"
	if [ -n "$destination" ]; then
		IFS="
		"
		for selection in $(printf '%s' "$SELECTED"); do
			unset IFS
			$cmd "$selection" "$destination"
		done && NotiPrompt \
			"Selected files / directories $cmdname to $destname"
	fi

}

DangerMenu () { # Usage: DangerMenu [CMD] [MSG] [Dest]
	IFS="
	"
	if DangerPrompt "$2"; then
		for selection in $(printf '%s' "$SELECTED"); do
			unset IFS
			if [ -z "$destination" ]; then
				$1 "$selection"
			else
				$1 "$selection" "$3"
			fi
		done && NotiPrompt "Selected removed."
	fi
}

BulkMode () { # Usage: BulkMode [MSG]
	HERE=
	bulklist=
	ActionMenu "$1" "$FM_ACTION_COLOR_BULK" \
		|| return && allowbulk="NotAllowed"
	while [ -n "$bulkselection" ]; do
		ActionMenu "$1" "$FM_ACTION_COLOR_BULK" \
			|| return && allowbulk="NotAllowed"
		HERE=$bulklist
		allowbulk="NotAllowed"
	done

	SELECTED=$(printf '%s' "$HERE" | uniq)
	allowbulk="NotAllowed"

	[ "$actCHOICE" = "$ENDSELECTION" ] \
		&& printf '%s' "$SELECTED" \
		| sed "/^$/ d" \
		| yprompt "Selected files (Enter to continue): " \
		"$FM_ACTION_COLOR_LV1"
}

# Actions that for dmenufm
# Note: Use `[ -n "$VAR" ]` after each menu to check
#	whether the menu is correctly execute.
# 	If not, then the later command will not execute.
FM_Action () {
	move=$(printf '%s\n' "$ACTLIST" \
		| yprompt "Actions:" "$FM_GENERIC_COLOR")
	case $move in
		"$FM_PCP")
			# Copy path to xclip, and send notification.
			ActionMenu "Copy directory/file path: " \
				"$FM_ACTION_COLOR_LV1" || return
			[ -n "$HERE" ] && printf '%s' "$HERE" \
				| xclip -selection clipboard \
				&& NotiPrompt "Path $name copied to clipboard."
			;;
		"$FM_NEW")
			name=$(xprompt "Dir ends w/ slash; File w/o: " "$FM_ACTION_COLOR_LV1") || return
			if [ -n "$( printf "$name" | grep '/')" ]; then
				mkdir -p "$name" \
					&& NotiPrompt "Directory $name created."
			else
				:>"$name" \
					&& NotiPrompt "File $name created."
			fi
			;;
		"$FM_MVV"|"$FM_YAK"|"$FM_LNK")
			case "$move" in
				"$FM_MVV")
					cmd="mv"
					cmdname="moved"
					cmdverb="move"
					allowbulk="Bulk Move"
					allselection="Bulk Move all"
					;;
				"$FM_YAK")
					cmd="cp -R"
					cmdname="copied"
					cmdverb="copy"
					allowbulk="Bulk Copy"
					allselection="Bulk Copy all"
					;;
				"$FM_LNK")
					cmd="ln -s"
					cmdname="linked"
					cmdverb="link"
					allowbulk="Bulk Link"
					allselection="Bulk Link all"
					;;
			esac
			ActionMenu "Source: " "$FM_ACTION_COLOR_LV1" \
				|| return \
				&& allowbulk="NotAllowed"
			if [ -n "$bulkselection" ]; then
				# Multi-selection mode
				# No need for dangerousmessage
				BulkMode "Select files / directories to $cmdverb: "
				[ "$actCHOICE" = "$ENDSELECTION" ] \
					&& DestMenu
			elif [ "$actCHOICE" = "$allselection" ]; then
				# All-selection mode
				BulkListAll
				[ -n "$SELECTED" ] \
					&& DestMenu
			else
				# Single-selection mode
				[ -n "$HERE" ] \
					&& SELECTED="$HERE" \
				[ -d "$SELECTED" ] \
					&& cd "../"
				[ -n "$SELECTED" ] \
					&& DestMenu
			fi
			;;
		"$FM_ZIP")
			allowbulk="Bulk Compress"
			allselection="Bulk Compress all"
			compression_type=$(printf '%s\n' "$COMPRESSIONLIST" \
				| yprompt "Compression type: " "$FM_ACTION_COLOR_LV1" \
				|| return \
				&& allowbulk="NotAllowed")
			if echo "$compression_type" | grep -E '^tar|^zip'; then
				continue
			else
				allowbulk="NotAllowed"
			fi
			[ -n "$compression_type" ] \
				&& ActionMenu "Source: " "$FM_ACTION_COLOR_LV1" \
				|| return \
				&& allowbulk="NotAllowed"
			if [ -n "$bulkselection" ]; then
				BulkMode "Select files / directories to compress: "
				[ "$actCHOICE" = "$ENDSELECTION" ] && BulkCompress
			elif [ "$actCHOICE" = "$allselection" ]; then
				BulkListAll
				BulkCompress
			else
				SELECTED="$HERE"
				[ -n "$SELECTED" ] && BulkCompress
			fi
			;;
		"$FM_REM")
			allowbulk="Bulk Rename"
			allselection="Bulk Rename all"
			ActionMenu "Source: " \
				"$FM_ACTION_COLOR_LV1" \
				|| return \
				&& allowbulk="NotAllowed"
			if [ -n "$bulkselection" ]; then
				BulkMode "Select files / directories to rename: "
				[ -n "$SELECTED" ] && BulkRename
			elif [ "$actCHOICE" = "$allselection" ]; then
				BulkListAll
				BulkRename
			else

				SELECTED="$HERE"
				[ -n "$SELECTED" ] && BulkRename
			fi
			;;
		"$FM_DEL")
			# Allow multiple files to be selected
			allowbulk="Bulk Delete"
			allselection="Bulk Delete all"
			# Choose file/directory in current directory to remove
			ActionMenu "Remove file / directory: " \
				"$FM_ACTION_COLOR_LV1" \
				|| return \
				&& allowbulk="NotAllowed"
			if [ -n "$bulkselection" ]; then
				# Multi-selection mode
				BulkMode "Select files / directories to delete: "
				[ "$actCHOICE" = "$ENDSELECTION" ] \
					&& DangerMenu "rm -rf" "Delete all selected?" ""
			elif [ "$actCHOICE" = "$allselection" ]; then
				BulkListAll
				DangerMenu "rm -rf" "Delete all selected in $name?" ""
			else
				# Single-selection mode
				allowbulk="NotAllowed"
				# Check the chosen on is directory or not
				[ -n "$HERE" ] && [ -d "$HERE" ] && result=$?
				[ -n "$HERE" ] && SELECTED="$HERE" \
					&& DangerMenu "rm -rf" "Remove all the files / directories in $name?" ""
					[ "$result" = "0" ] && cd "../" && result=
			fi
			;;
		"$FM_TRH")
			# Allow multiple files to be selected
			allowbulk="Bulk Trash"
			allselection="Bulk Trash all"
			[ ! -d "$FM_TRASH" ] \
				&& mkdir -p "$FM_TRASH"
			trashmenu=$(printf '%s\n' "Move to trash" \
				"Go to trash" "Empty trash" \
				| yprompt "Dmenufm Trash" "$FM_GENERIC_COLOR")
			case $trashmenu in
				"Move to trash")
					ActionMenu "Move file/directory to trash: " \
						"$FM_ACTION_COLOR_LV1" \
						|| return \
						&& allowbulk="NotAllowed"
					if [ -n "$bulkselection" ]; then
						# Multi-selection mode
						BulkMode "Select files / directories to move to trash: "
						[ "$actCHOICE" = "$ENDSELECTION" ] \
							&& DangerMenu "mv" "Move all selected to trash?" "$FM_TRASH"
					elif [ "$actCHOICE" = "$allselection" ]; then
						BulkListAll
						DangerMenu "rm -rf" "Delete all selected in $name?" ""
					else
						# Single-selection mode
						allowbulk="NotAllowed"
						# Check the chosen on is directory or not
						[ -n "$HERE" ] && [ -d "$HERE" ] && result=$?
						[ -n "$HERE" ] && SELECTED="$HERE" \
							&& DangerMenu "rm -rf" "Remove all the files / directories in $name?" ""
							[ "$result" = "0" ] && cd "../" && result=
					fi
					;;
				"Go to trash")
					cd "$FM_TRASH" || return
					;;
				"Empty trash")
					# Lesson: You cannot quote a wildcard. No quote on *.
					if DangerPrompt "Remove all files and/or directory in trash?" \
						&& rm -rf "$FM_TRASH"/*; then
						NotiPrompt "Trash is empty." || return
					else
						return
					fi
					;;
			esac
			;;
		"$FM_HIS")
			# Use sed command to mimic reverse of cat for POSIX.
			goto=$(sed '1!G;h;$!d' "$FM_HISFILE" \
				| yprompt "Dmenufm History" "$FM_GENERIC_COLOR")
			destination=${goto##* - }
			cd "$destination" || return
			;;
		"$FM_BMK")
			markmenu=$(printf '%s\n' "$(cat -u "$FM_BMKFILE")" \
				"Add BMK" "Delete BMK" \
				|  yprompt "Dmenufm Bookmark" "$FM_GENERIC_COLOR")
			case "$markmenu" in
				"Add BMK")
					ActionMenu "Choose file / directory and add to BMK: " \
						"$FM_ACTION_COLOR_LV1" || return
					mark=${HERE##*/}
					[ -n "$mark" ] \
						&& printf '%s\n' "$mark - $HERE" >> "$FM_BMKFILE"
					[ -n "$mark" ] \
						&& sed "/^$/ d" "$FM_BMKFILE" \
						> "$FM_BMKFILE.backup" \
						&& cp "$FM_BMKFILE.backup" "$FM_BMKFILE"
					;;
				"Delete BMK")
					delbmk=$(< "$FM_BMKFILE" \
						yprompt "Delete chosen bmk: " "darkred") \
						|| return
					# POSIX way of sed -i.
					# Assign address as '=' by '\=pattern='
					# Create backup file and cp to original file.
					[ -n "$delbmk" ] \
						&& sed "\=$delbmk= d" "$FM_BMKFILE" \
						> "$FM_BMKFILE.backup" \
						&& cp "$FM_BMKFILE.backup" "$FM_BMKFILE"
					;;
				*)
					destination=${markmenu##* - }
					if [ -n "$destination" ]; then
						cd "$destination" || FileOpen "$destination"
					fi
			esac
			;;
		"$FM_CMD")
			cmdmenu=$(printf '%s\n' "$(cat -u "$FM_CMDFILE")" \
				"Add CMD" "Delete CMD" \
				| yprompt "Dmenufm Custom Command" "$FM_GENERIC_COLOR")
			case "$cmdmenu" in
				"Add CMD")
					addcmd=$(xprompt "Recording your command: " \
						"$FM_ACTION_COLOR_LV1") || return
					desp=$(xprompt "Enter command description: " \
						"$FM_ACTION_COLOR_LV1") || return
					[ -n "$addcmd" ] \
						&& printf '%s\n' "$addcmd - $desp" \
						>> "$FM_CMDFILE"
					[ -n "$addcmd" ] \
						&& sed "/^$/ d" "$FM_CMDFILE" \
						> "$FM_CMDFILE.backup" \
						&& cp "$FM_CMDFILE.backup" "$FM_CMDFILE"
					;;
				"Delete CMD")
					delcmd=$(< "$FM_CMDFILE" \
						yprompt "Delete chosen command: " "darkred")
					# POSIX way of sed -i.
					# Assign address as '+' by '\+pattern+'
					# '=' seems not usable in command
					# Create backup file and cp to original file.
					[ -n "$delcmd" ] \
						&& sed "\:$delcmd: d" "$FM_CMDFILE" \
						> "$FM_CMDFILE.backup" \
						&& cp "$FM_CMDFILE.backup" "$FM_CMDFILE"
					;;
				*)
					execmd=${cmdmenu%% - *}
					if printf '%s' "$execmd" | grep '\$'; then
						allowbulk="Bulk Execute"
						allselection="Bulk Execute all"
						ActionMenu "Choose and execute: " "$FM_ACTION_COLOR_LV1"
						if [ -n "$bulkselection" ]; then
							BulkMode "Select to execute: "
							BulkCMD
						elif [ "$actCHOICE" = "$allselection" ]; then
							BulkListAll
							BulkCMD
						else
							SELECTED="$HERE"
							BulkCMD
						fi
					else
						ExecCMD "$execmd"
					fi
					;;
			esac
			;;
	esac
	MainMenu
}

### MAIN FUNCTIONS

MainMenu () {
	while [ -n "$CHOICE" ]; do
		UpdateMenu
		# Default menu list if no arguments given
		[ -z "$keeplist" ] \
			&& Menu \
			&& list=$(printf '%s\n' "$DIRs" "$FILEs" "$DOTDIRs" "$DOTFILEs")
		# Generate menu with/without arguments
		# Show only the current directory and one level of parent directory
		if [ "$rollingmenu" = "true" ] && [ -f "$CHOICE" ]; then
			list=$(printf '%s\n' "$CHOICE" "${list##*$CHOICE}" "${list%%$CHOICE*}" | sed "/^$/ d")
		fi
		TMP="$(printf '%s' "${PWD%%/${PWD##*/}}")"
		TwoPWD="$(printf '%s' "${TMP##*/}/${PWD##*/}")"
		unset TMP
		CHOICE=$(printf '%s\n' "$BACKWARD" "$TARGET" \
			"$ACTION" "$TERM" "$list" \
			| sed "/^$/ d" \
			| yprompt "$TwoPWD" "$FM_GENERIC_COLOR")
		# Outcome matching
		if [ "$CHOICE" = "$TARGET" ]; then
			if [ "$termpath" = "true" ]; then
				printf "$PWD" && CHOICE=""
				break
			else
				FileOpen "$PWD"
			fi
		elif [ "$CHOICE" = "$BACKWARD" ]; then
			cd "../"
			History
		elif [ "$CHOICE" = "$ACTION" ]; then
			FM_Action
		elif [ "$CHOICE" = "$TERM" ]; then
			$TERMINAL
		elif [ -d "$CHOICE" ]; then
			cd "$CHOICE" || exit 1
			History
			continue
		elif [ -f "$CHOICE" ]; then
			if [ "$termpath" = "true" ]; then
				printf "$PWD/$CHOICE" && CHOICE=""
				break
			else
				FileOpen "$PWD/$CHOICE"
			fi
		else
			break
		fi
	done
}


UsageInfo () {
	while read -r CurLine; do
		printf "%b\n" "$CurLine"
	done <<-EOF
		\r            DMENUFM
		\r            Written by huijunchen9260 (chen.9260@osu.edu)
		\r
		\r            Simple file manager using dmenu
		\r
		\rSYNTAX:     dmenufm [OPTS]
		\r
		\rOPTS:       -h | --help               - Show this usage information.
		\r            -d | --directory          - Only directories.
		\r            -f | --file               - Only show files.
		\r            -D | --dotdirectory       - Only show hidden directories.
		\r            -F | --dotfile            - Only show hidden files.
		\r            -p | --lastpath           - Opens in last working directory. (cd on exit)
		\r            -r | --rollingmenu        - Rolling menu based on selected files.
		\r            -t | --textpath           - Print out the path of file / directory.
	EOF

	unset CurLine
}


### ARGUMENTS

while [ -n "$1" ]; do
	case $1 in
		"-d"|"--directory" ) keeplist="${keeplist} DIRs" ;;
		"-f"|"--file" ) keeplist="${keeplist} FILEs" ;;
		"-D"|"--dotdirectory" ) keeplist="${keeplist} DOTDIRs" ;;
		"-F"|"--dotfile" ) keeplist="${keeplist} DOTFILEs" ;;
		"-p"|"--lastpath" ) outputpath="placeholder" ;;
		"-r"|"--rollingmenu") rollingmenu="true" ;;
		"-t"|"--termpath") termpath="true" ;;
		"-h"|"--help" ) UsageInfo; exit 0; ;;
		*)
			if [ -d "$1" ]; then
				cd "$1"
			elif [ -f "$1" ]; then
				FileOpen "$1"
			else
				printf '%s\n' "Invalid option. Use -h to read help"
				exit 1
			fi
			;;
	esac
	shift
done

### RUN THE MAIN FUNCTION

# --lastpath option:
[ -n "$outputpath" ] && cd "$(cat -u "$FM_LASTPATH")"

MainMenu

printf '%s' "$PWD" > "$FM_LASTPATH"
