#!/bin/sh

# Dmenu-based directory browser
#
# Dependency:
#
#   dmenu, xclip, xdg-mime
#
# Dependency on extraction:
#
#   tar, unlzma, bunzip2, unrar, unzip, uncompress, 7z, unxz, cabextract


### OPTIONS AND VARIABLES

## OPTIONS
# FILES LOCATION
[ -n "$FMPath" ] || FMPath="$HOME/.config/dmenufm"
[ -n "$FMTrash" ] || FMTrash="$FMPath/trash"
[ -n "$FMBMKFile" ] || FMBMKFile="$FMPath/dmenufm_bookmark"
[ -n "$FM_CMDFILE" ] || FM_CMDFILE="$FMPath/dmenufm_command"
[ -n "$FM_HISFILE" ] || FM_HISFILE="$FMPath/dmenufm_history"
[ -n "$FMLastPath" ] || FMLastPath="$FMPath/dmenufm_lastpath"
[ -n "$FMRemFile" ] || FMRemFile="$FMPath/dmenufm_bulk_rename"
[ -n "$FMZipPath" ] || FMZipPath="$FMPath/compression/"

# Max number for history
[ -n "$FM_MAX_HIS_LENGTH" ] || FM_MAX_HIS_LENGTH=5000

# FONTS
[ -n "$FM_GENERIC_FONT" ] || FM_GENERIC_FONT="Monospace-15"
[ -n "$FM_NOTIF_FONT" ] || FM_NOTIF_FONT="Monospace-25"
[ -n "$FM_DANGER_FONT" ] || FM_DANGER_FONT="Monospace-20"

# COLORs
[ -n "$FMGenericColor" ] || FMGenericColor="#005577"
[ -n "$FMActionColorLV1" ] || FMActionColorLV1="#33691e"
[ -n "$FM_ACTION_COLOR_LV2" ] || FM_ACTION_COLOR_LV2="#FF8C00"
[ -n "$FM_ACTION_COLOR_BULK" ] || FM_ACTION_COLOR_BULK="#CB06CB"

# xdg-open directories
XDGDIR1='/usr/share/applications'
XDGDIR2='/usr/local/share/applications'

## GLOBAL VARIABLES
Choice='placeholder'
ActChoice='placeholder'
AllSelection='placeholder'
TARGET='./'
BACKWARD='../'
ENDSELECTION='End Selection'
AllowBulk='NotAllowed'
ACTION='Actions'
TERM='Terminal'

FM_PCP='PCP - Copy path'
FM_NEW='NEW - Create new file / directory'
FM_DEL='DEL - Delete files / directories'
FM_MVR='MVR - Move files / directories'
FM_YAK='YAK - Copy files / directories'
FM_LNK='LNK - Symbolically link files / directories'
FM_REM='REM - Rename files / directories'
FM_TRH='TRH - Trash of dmenufm'
FM_HIS='HIS - History of dmenufm'
FM_BMK='BMK - Bookmark for dmenufm'
FM_CMD='CMD - Frequently used command'
FM_ZIP='ZIP - Compress files / directories'

# These two are concatenated for code readability.
ActionList="$FM_PCP:$FM_NEW:$FM_MVR:$FM_YAK:$FM_LNK:$FM_DEL"
ActionList="$ActionList:$FM_TRH:$FM_REM:$FM_HIS:$FM_BMK:$FM_CMD:$FM_ZIP"

COMPRESSIONLIST='tar.gz tar.bz2 tar.xz xz lzma gz bz2 7z zip'

### FUNCTIONS

LineCount () { # Usage: [CMD |] LineCount [< FILE]
	Count=0
	while read -r CurLine; do
		Count=$((Count + 1))
	done < /dev/stdin
	printf "%d\n" $Count

	unset CurLine Count
}

## PRE-DETERMINATION FUNCTION

# Check os
GetOSType () {
	case $OSTYPE in
		# Mac OS X / macOS.
		darwin*) FM_OPENER=open ;;
	esac
}

## OPEN FUNCTIONS

# You may need to modify ExecuteCMD
# to match how your terminal execute the command.
# See README.md for more detail
ExecuteCMD () {
	Command=$1
	software=$(printf '%s' "${Command%% *}")
	appdesktop=$(find "$XDGDIR1" "$XDGDIR2" -name "*$software*.desktop" | tail -n 1)
	if [ -n "$appdesktop" ] && grep 'Terminal=false' "$appdesktop"; then
		printf '%s' "$Command" | ${SHELL:-"/bin/sh"}
	else
		$TERMINAL -e $Command | ${SHELL:-"/bin/sh"}
	fi
}

# Open files with xdg-open, if not compression.
# Compressions are extracted by its file extension.
# Use extraction to put content in a new directory.
# To edit default applications in xdg-open,
# sudo $EDITOR /usr/share/applications/mimeinfo.cache
FileOpen () {
	# Extract files and make a new directory to contain all the files.
	extraction () {
		# $1: command to extract compress
		# $2: compression name
		# Example: extraction "unzip" "$HOME/filename.zip"

		DirName=${2##*/}

		if mkdir -p $DirName; then
			cd "$DirName"
		else
			exit
		fi

		$1 "$2"

		notifyprompt "$Choice extracted to $DirName"
	}

	mimetype=$(xdg-mime query filetype "$1")
	case $1 in
		*.tar.bz2|*.tar.xz|*.tbz2)
			extraction "tar xvjf" "$1" ;;
		*.tar.gz|*.tgz)
			extraction "tar xvzf" "$1" ;;
		*.lzma)
			extraction "unlzma" "$1" ;;
		*.bz2)
			extraction "bunzip2" "$1" ;;
		*.rar)
			extraction "unrar x -ad" "$1" ;;
		*.gz)
			extraction "gunzip" "$1" ;;
		*.tar)
			extraction "tar xvf" "$1" ;;
		*.zip)
			extraction "unzip" "$1" ;;
		*.Z)
			extraction "uncompress" "$1" ;;
		*.7z)
			extraction "7z x" "$1" ;;
		*.xz)
			extraction "unxz" "$1" ;;
		*.cab)
			extraction "cabextract" "$1" ;;
		*)
			case $mimetype in
				text/*|*x-empty*|*json*)
					# Text file opened in $EDITOR or default opener
					if [ -n "$TERMINAL" ] && [ -n "$EDITOR" ]; then
						$TERMINAL -e $EDITOR "$1"
					else
						${FM_OPENER:-xdg-open} "$1"
					fi
					;;
				*)
					appdesktop=$(xdg-mime query default "$mimetype")

					if < "$(find "$XDGDIR1" "$XDGDIR2" -name "$appdesktop" \
						| tail -n 1)" grep "Terminal=false"; then
						${FM_OPENER:-xdg-open} "$1"
					else
						$TERMINAL -e ${FM_OPENER:-xdg-open} "$1"
					fi
					;;
			esac
	esac

	unset -f extraction
	unset mimetype
}


## MENUFUNCTIONS

# Generate directories
# Variables cannot store multiline string, so transform to ':'
# Misbehaving due to space in file/directory name,
# so add ' at beginning and end.

# This isn't being used.
#DoQuote () { printf "'%s'\n" "$1"; }

# Generate default menu
menu () {
	ForCurItem () { # Usage: ForCurItem {[-f FILE] | [-d DIRECTORY]}
		Arg=$1
		shift

		for CurItem in "$@"; do
			[ $Arg "$CurItem" ] && printf '%s:' "$CurItem"/
		done

		unset CurItem Arg
	}

	ForCurItem '-d' ./* # <-- Generate directories.
	ForCurItem '-d' ./.* | sed 's|./||; s|../||' # <-- Generate dot-directories.
	ForCurItem '-f' ./* # <-- Generate files.
	ForCurItem '-f' ./.* # <-- Generate dot-files.
}

# Update menu in each move
UpdateMenu () {
	list=
	# Rebuild list in every move
	for element in $KeepList; do
		case $element in
			DIRs)
				menudir && list="$list$DIRs" ;;
			FILEs)
				menufile && list="$list$FILEs" ;;
			DOTDIRs)
				menudotdir && list="$list$DOTDIRs" ;;
			DOTFILEs)
				menudotfile && list="$list$DOTFILEs" ;;
		esac
	done
}

				# | sed "s/'//g; /^$/ d" \
# Generate menu for action choice, only for current directory.
# $1 is the prompt, $2 is the selected background color
GenActMenu () {
	while [ -n "$ActChoice" ]; do
		UpdateMenu
		# Default menu list if no arguments given
		[ -z "$KeepList" ] && menu \
			&& list="$DIRs$FILEs$DOTDIRs$DOTFILEs"
		# Generate menu with/without arguments
		# Show only the current directory and one level of parent directory
		TwoPWD=$(printf '%s' "$PWD" \
			| awk -F '/' '{print $(NF-1)"/"$NF}')
		if [ -n "$bulkselection" ]; then
			ActChoice=$(printf '%s:' "$BACKWARD" "$TARGET" \
				"$ENDSELECTION" "$list" \
				| tr ':' '\n' \
				| sed "/^$/ d" \
				| yprompt "$1" "$2")
		elif [ "$AllowBulk" != "NotAllowed" ]; then
			ActChoice=$(printf '%s:' "$BACKWARD" "$TARGET" \
				"$AllowBulk" "$AllSelection" "$list" \
				| tr ':' '\n' \
				| sed "/^$/ d" \
				| yprompt "$1" "$2")
		else
			ActChoice=$(printf '%s:' "$BACKWARD" "$TARGET" "$list" \
				| tr ':' '\n' \
				| sed "/^$/ d" \
				| yprompt "$1" "$2")
		fi
		# Outcome matching
		if [ "$ActChoice" = "$TARGET" ]; then
			Here=$(printf '%s' "$PWD")
			name=$(printf '%s' "$Here" \
				| awk -F '/' '{print $NF}')
			[ -n "$bulkselection" ] \
				&& bulklist="$bulklist:$Here" \
				&& cd "../"
			break
		elif [ "$ActChoice" = "$BACKWARD" ]; then
			cd "../" || return
			dmenufm_history
		elif [ "$ActChoice" = "$ENDSELECTION" ]; then
			bulkselection=
			break
		elif [ "$ActChoice" = "$AllowBulk" ]; then
			bulkselection="true"
			break
		elif [ "$ActChoice" = "$AllSelection" ]; then
			bulkselection=
			Here=$(printf '%s' "$PWD")
			name=$(printf '%s' "$Here" \
				| awk -F '/' '{print $NF}')
			break
		elif [ -d "$ActChoice" ]; then
			cd "$ActChoice" || exit 1
			dmenufm_history
			continue
		elif [ -f "$ActChoice" ] || [ -n "$rename" ]; then
			Here=$(printf '%s' "$PWD/$ActChoice")
			name=$(printf '%s' "$Here" \
				| awk -F '/' '{print $NF}')
			[ -n "$bulkselection" ] \
				&& bulklist="$bulklist:$Here"
			break
		else
			Here=
			name=
			bulkselection=
			ActChoice="placeholder"
			break
		fi
	done
}

## PROMPT FUNCTIONS
yprompt () {
	# $1 is prompt
	dmenu -fn "$FM_GENERIC_FONT" -i -sb "$2" -l 10 -p "$1"
}

xprompt () {
	# $1 is prompt
	dmenu -fn "$FM_GENERIC_FONT" -i -sb "$2" -p "$1" <&-
}

notifyprompt () {
	dmenu -fn "$FM_NOTIF_FONT" -sb "#d79921" -sf "#1d2021" \
		-nf "#000000" -nb "#000000" -p "$1" <&-
}

# Prompt that used in dangerous action
DangerPrompt () {
	# From Luke Smith
	# Use && command to execute the command after "Yes"
	[ "$(printf "No\\nYes" \
		| dmenu -fn "$FM_DANGER_FONT" -i -p "$1" \
		-nb darkred -sb red -sf white -nf gray )" = "Yes" ]
}


## TOOL FUNCTIONS


BulkAllList () {
	SELECTED=$(printf '%s' "$list" \
		| tr ':' '\n' \
		| sed "/^$/ d; s=^=$PWD/=g")
	[ -n "$SELECTED" ] \
		&& printf '%s' "$SELECTED" \
		| yprompt "Selected files (Enter to continue): " "$FMActionColorLV1"
}

# Store every move between directories into history
dmenufm_history () {
	[ ! -d "$FMPath" ] && mkdir -p "$FMPath"
	printf '%s - %s\n' "${dirmark##*/}" "$PWD" >> "$FM_HISFILE"

	# Limit the max number of history
	hisnum_line=$(LineCount < "$FM_HISFILE")

	if [ "${hisnum_line%% *}" -ge "$FM_MAX_HIS_LENGTH" ]; then
		sed '1d' "$FM_HISFILE" > "$FM_HISFILE.backup" && {
			cp "$FM_HISFILE.backup" "$FM_HISFILE"
		}
	fi

	unset dirmark hisnum_line
}

# Bulk compression

bulk_compress () {
	case $compression_type in
		 tar.gz) Command='tar -czvf' ;;
		 tar.xz) Command='tar -cJvf' ;;
		tar.bz2) Command='tar -cjvf' ;;
		     gz) Command='gzip -k' ;;
		    bz2) Command='bzip2 -k' ;;
		     xz) Command='xz -k' ;;
		   lzma) Command='lzma -k' ;;
		     7z) Command='7z a' ;;
		    zip) Command='zip -r' ;;
		      *) return ;;
	esac

	case $compression_type in
		tar*|zip*)
			[ -d "$FMZipPath" ] && rm -rf "$FMZipPath"
			mkdir "$FMZipPath"

			IFS="
			"

			for file in $SELECTED; do
				unset IFS
				cp -R "$file" "$FMZipPath"
			done

			MSG='Please insert archive name: '
			archive_name=$(xprompt "$MSG" "$FM_ACTION_COLOR_LV2" | cut -d '.' -f 1)
			[ $? -ne 0 ] && return

			compressdir_name=$archive_name
			archive_name=$archive_name.$compression_type
			mv "$FMZipPath" "./$compressdir_name"

			if $Command "$archive_name" "./$compressdir_name"/*; then
				notifyprompt "Compressed to $archive_name"
			fi

			rm -rf ./"$compressdir_name"
			;;
		''|*)
			IFS="
			"

			for file in $SELECTED; do
				unset IFS
				$Command "$file" \
					&& notifyprompt "Compressed to $archive_name"
			done
			;;
	esac
	## TODO: Add error handling
	## TODO: Make sure you can escape out of all ZIP commands
		# Added, but need testing

	unset MSG
}


# Bulk rename function.
# No argument

bulk_rename () {
	if [ -n "$SELECTED" ]; then
		printf '%s\n' "$SELECTED" | sed "s=/$==g" > "$FMRemFile.backup"
		awk -F '/' '{print $NF}' "$FMRemFile.backup" > "$FMRemFile"
		awk -F '/' '{$NF=""; print $0}' "$FMRemFile.backup"\
			| tr ' ' '/' > "$FMRemFile.DirName"

		FileOpen "$FMRemFile"

		LeftNum=$(LineCount < "$FMRemFile")
		RightNum=$(LineCount < "$FMRemFile.backup")

		if [ $LeftNum -ne $RightNum ]; then
			notifyprompt "ERROR: Lines mismatch in rename file; do nothing."\
				&& return
		else
			renamevar=$(paste -d ':' "$FMRemFile.backup" "$FMRemFile.DirName" "$FMRemFile")

			# Set IFS for for loop as \n
			IFS="
			"

			for selection in $renamevar; do
				start=${selection%%:*}
				Dest=$(printf '%s' "$selection" | cut -d ':' -f 2,3)
				if [ "$start" = "$Dest" ]; then
					continue
				else
					mv "$start" "$Dest"
				fi
			done && notifyprompt "Selected renamed"
			unset IFS
		fi
	else
		return
	fi

	unset LeftNum RightNum
}

BulkCMD () {
	execfile=$(printf '%s' "$SELECTED")
	ExecCMD=$(printf '%s' "$ExecCMD" | sed "1 s/$.*//")
	IFS="
	"
	for selection in $(printf '%s' "$execfile"); do
		unset IFS
		$ExecCMD "$selection"
	done && notifyprompt "Command executed on selected."
}

destmenu () {
	GenActMenu "Destination: " \
		"$FM_ACTION_COLOR_LV2" \
		|| return \
		&& rename= \
		&& AllowBulk="NotAllowed" \
		&& ActChoice="placeholder"
	[ -n "$Here" ] \
		&& Dest="$Here" \
		&& destname="$name"
	if [ -n "$Dest" ]; then
		IFS="
		"
		for selection in $(printf '%s' "$SELECTED"); do
			unset IFS
			$Command "$selection" "$Dest"
		done && notifyprompt \
			"Selected files / directories $CMDName to $destname"
	fi

}

dangermenu () {
	Command=$1
	dangermessage=$2
	Dest=$3
	IFS="
	"
	if DangerPrompt "$dangermessage"; then
			for selection in $(printf '%s' "$SELECTED"); do
				unset IFS
				if [ -z "$Dest" ]; then
					$Command "$selection"
				else
					$Command "$selection" "$Dest"
				fi
			done && notifyprompt "Selected removed."
	fi
}

BulkMode () {
	# $1 for the prompt when multi selecting
	bulkprompt=$1
	Here=
	bulklist=
	GenActMenu "$bulkprompt" "$FM_ACTION_COLOR_BULK" \
		|| return && AllowBulk="NotAllowed"
	while [ -n "$bulkselection" ]; do
		GenActMenu "$bulkprompt" "$FM_ACTION_COLOR_BULK" \
			|| return && AllowBulk="NotAllowed"
		Here=$bulklist
		AllowBulk="NotAllowed"
	done

	SELECTED=$(printf '%s' "$Here" \
		| cut -b 2- \
		| tr ':' '\n' \
		| uniq)
	AllowBulk="NotAllowed"

	[ "$ActChoice" = "$ENDSELECTION" ] \
		&& printf '%s' "$SELECTED" \
		| yprompt "Selected files (Enter to continue): " \
		"$FMActionColorLV1"
}

# Actions which are for dmenufm.
#
# NOTE: Use `[ -n "$VAR" ]` after each menu to check whether the menu is correctly
#       executed, else, the later command will not execute.
#
dmenufm_action () {
	move=$(printf '%s' "$ActionList" | tr ':' '\n' | yprompt "Actions:" "$FMGenericColor")
	#for CurAction in $ActionList

	case $move in
		"$FM_PCP")
			# Copy path to xclip, and send notification.
			GenActMenu "Copy selected item path: " \
				"$FMActionColorLV1" || return
			[ -n "$Here" ] && printf '%s' "$Here" \
				| xclip -selection clipboard \
				&& notifyprompt "Path $name copied to clipboard." ;;
		"$FM_NEW")
			name=$(xprompt "Dir ends w/ slash; File w/o: " "$FMActionColorLV1")
			[ $? -ne 0 ] && return

			if [ -n "$( printf "$name" | grep '/')" ]; then
				mkdir -p "$name" && notifyprompt "Directory $name created."
			else
				> "$name" && notifyprompt "File $name created."
			fi ;;
		"$FM_MVR"|"$FM_YAK"|"$FM_LNK")
			case $move in
				"$FM_MVR")
					Command='mv'
					CMDName='moved'
					CMDVerb='move'
					AllowBulk='Bulk Move'
					AllSelection='Bulk Move all' ;;
				"$FM_YAK")
					Command='cp -R'
					CMDName='copied'
					CMDVerb='copy'
					AllowBulk='Bulk Copy'
					AllSelection='Bulk Copy all' ;;
				"$FM_LNK")
					Command='ln -s'
					CMDName='linked'
					CMDVerb='link'
					AllowBulk='Bulk Link'
					AllSelection='Bulk Link all' ;;
			esac

			if GenActMenu "Source: " "$FMActionColorLV1"; then
				AllowBulk="NotAllowed"
			else
				return
			fi

			if [ -n "$bulkselection" ]; then
				# Multi-selection mode. No need for dangerousmessage.
				BulkMode "Select files / directories to $CMDVerb: "

				[ "$ActChoice" = "$ENDSELECTION" ] && destmenu
			elif [ "$ActChoice" = "$AllSelection" ]; then
				# All-selection mode
				BulkAllList

				[ -n "$SELECTED" ] && destmenu
			else
				# Single-selection mode
				if [ -n "$Here" ]; then
					SELECTED="$Here"
					rename="true"
				fi

				[ -d "$SELECTED" ] && cd "../"
				[ -n "$SELECTED" ] && destmenu

				rename=
			fi ;;
		"$FM_ZIP")
			AllowBulk='Bulk Compress'
			AllSelection='Bulk Compress all'

			ChooseType () {
				for CurType in $COMPRESSIONLIST; do
					printf "%s\n" "$CurType"
				done

				unset CurType
			}

			compression_type=$(
				printf '%s' "$COMPRESSIONLIST" | tr ' ' '\n' \
					| yprompt "Compression type: " "$FMActionColorLV1" \
					|| return && AllowBulk="NotAllowed"
			)

			if printf "%s\n" "$compression_type" | grep -E '^tar|^zip'; then
				continue
			else
				AllowBulk='NotAllowed'
			fi

			[ -n "$compression_type" ] \
				&& GenActMenu "Source: " "$FMActionColorLV1" \
				|| return \
				&& AllowBulk="NotAllowed"
			if [ -n "$bulkselection" ]; then
				BulkMode "Select files / directories to compress: "
				[ "$ActChoice" = "$ENDSELECTION" ] && bulk_compress
			elif [ "$ActChoice" = "$AllSelection" ]; then
				BulkAllList
				bulk_compress
			else
				SELECTED=$Here
				[ -n "$SELECTED" ] && bulk_compress
			fi

			unset -f ChooseType ;;
		"$FM_REM")
			AllowBulk='Bulk Rename'
			AllSelection='Bulk Rename all'

			if GenActMenu 'Source: ' "$FMActionColorLV1"; then
				AllowBulk='NotAllowed'
			else
				return
			fi

			if [ -n "$bulkselection" ]; then
				BulkMode "Select files / directories to rename: "
				[ -n "$SELECTED" ] && bulk_rename
			elif [ "$ActChoice" = "$AllSelection" ]; then
				BulkAllList
				bulk_rename
			else

				SELECTED="$Here"
				[ -n "$SELECTED" ] && bulk_rename
			fi ;;
		"$FM_DEL")
			# Allow multiple files to be selected
			AllowBulk="Bulk Delete"
			AllSelection="Bulk Delete all"
			# Choose file/directory in current directory to remove
			GenActMenu "Remove file / directory: " \
				"$FMActionColorLV1" \
				|| return \
				&& AllowBulk="NotAllowed"
			if [ -n "$bulkselection" ]; then
				# Multi-selection mode
				BulkMode "Select files / directories to remove: "
				[ "$ActChoice" = "$ENDSELECTION" ] \
					&& dangermenu "rm -rf" "Delete all selected?" ""
			elif [ "$ActChoice" = "$AllSelection" ]; then
				BulkAllList
				dangermenu "rm -rf" "Delete all selected in $name?" ""
			else
				# Single-selection mode
				AllowBulk="NotAllowed"
				# Check the chosen on is directory or not
				[ -n "$Here" ] && [ -d "$Here" ] && result=$?
				[ -n "$Here" ] && SELECTED="$Here" \
					&& dangermenu "rm -rf" "Remove all the files / directories in $name?" ""
					[ "$result" = "0" ] && cd "../" && result=
			fi ;;
		"$FM_TRH")
			# Allow multiple files to be selected
			AllowBulk="Bulk Trash"
			AllSelection="Bulk Trash all"
			[ ! -d "$FMTrash" ] \
				&& mkdir -p "$FMTrash"
			trashmenu=$(printf '%s\n' "Move to trash" \
				"Go to trash" "Empty trash" \
				| sed "/^$/ d" \
				| yprompt "Dmenufm Trash" "$FMGenericColor")
			case $trashmenu in
				"Move to trash")
					GenActMenu "Move file/directory to trash: "\
						"$FMActionColorLV1" && AllowBulk="NotAllowed" || return

					if [ -n "$bulkselection" ]; then
						# Multi-selection mode
						BulkMode "Select files and/or directories to move to trash: "
						if [ "$ActChoice" = "$ENDSELECTION" ]; then
							dangermenu 'mv' "Send selection to trash?" "$FMTrash"
						fi
					elif [ "$ActChoice" = "$AllSelection" ]; then
						BulkAllList
						dangermenu 'rm -rf' "Delete selection in '$name' directory?" ''
					else
						# Single-selection mode
						AllowBulk='NotAllowed'
						# Check the chosen on is directory or not
						[ -n "$Here" ] && [ -d "$Here" ] && result=$?
						[ -n "$Here" ] && SELECTED="$Here" \
							&& dangermenu 'rm -rf' "Remove all the files / directories in $name?" ''
							[ "$result" = "0" ] && cd "../" && result=
					fi ;;
				'Go to trash')
					cd "$FMTrash" || return ;;
				'Empty trash')
					if DangerPrompt 'Empty the dmenufm trash?'; then
						if rm -rf "$FMTrash"/*; then; then
							notifyprompt "Trash successfully emptied."
						else
							return
						fi
					else
						return
					fi ;;
			esac ;;
		"$FM_HIS")
			# Use sed command to mimic reverse of cat for POSIX.
			goto=$(sed '1!G;h;$!d' "$FM_HISFILE" \
				| yprompt "Dmenufm History" "$FMGenericColor")
			Dest=$(printf '%s' "$goto" \
				| awk -F ' - ' '{print $2}')
			cd "$Dest" || return ;;
		"$FM_BMK")
			MarkMenu=$(printf '%s\n' "$(cat -u "$FMBMKFile")" 'Add BMK' 'Delete BMK'\
				| sed '/^$/d' | yprompt "Dmenufm Bookmark" "$FMGenericColor")

			case $MarkMenu in
				'Add BMK')
					GenActMenu "Choose file / directory and add to BMK: " \
						"$FMActionColorLV1" || return

					Mark=${Here##*/}
					if [ -n "$Mark" ]; then
						printf '%s\n' "$Mark - $Here" >> "$FMBMKFile"

						if sed "/^$/ d" "$FMBMKFile" > "$FMBMKFile.backup"; then
							cp "$FMBMKFile.backup" "$FMBMKFile"
						fi
					fi ;;
				'Delete BMK')
					# TODO: This is broken; not Bourne POSIX because of $(< FILE).
					#       It could probably do with a rework anyway.
					DelBMK=$(< "$FMBMKFile" yprompt "Delete chosen bmk: " "darkred")
					[ $? -ne 0 ] || return

					# Create backup file and cp to original file.
					if [ -n "$DelBMK" ]; then
						while read -r CurLine; do
							if ! [ "$CurLine" = "$DelBMK" ]; then
								printf "%s\n" "$CurLine"
							fi
						done < "$FMBMKFile" > "$FMBMKFile.backup"
						cp "$FMBMKFile.backup" "$FMBMKFile"
					fi ;;
				*)
					Dest=$(printf '%s' "$MarkMenu" | awk -F ' - ' '{print $2}')

					if [ -n "$Dest" ]; then
						cd "$Dest" || FileOpen "$Dest"
					fi ;;
			esac ;;
		"$FM_CMD")
			cmdmenu=$(printf '%s\n' "$(cat -u "$FM_CMDFILE")" \
				"Add CMD" "Delete CMD" "Choose and execute" \
				| sed "/^$/ d" \
				| yprompt "Custom dmenufm Command" "$FMGenericColor")

			case $cmdmenu in
				"Add CMD")
					addcmd=$(xprompt "Recording your command: " \
						"$FMActionColorLV1") || return
					desp=$(xprompt "Enter command description: " \
						"$FMActionColorLV1") || return
					[ -n "$addcmd" ] \
						&& printf '%s\n' "$addcmd - $desp" \
						>> "$FM_CMDFILE"
					[ -n "$addcmd" ] \
						&& sed "/^$/ d" "$FM_CMDFILE" \
						> "$FM_CMDFILE.backup" \
						&& cp "$FM_CMDFILE.backup" "$FM_CMDFILE" ;;
				"Delete CMD")
					delcmd=$(< "$FM_CMDFILE" \
						yprompt "Delete chosen command: " "darkred")
					# POSIX way of sed -i.
					# Assign address as '+' by '\+pattern+'
					# '=' seems not usable in command
					# Create backup file and cp to original file.
					[ -n "$delcmd" ] \
						&& sed "\:$delcmd: d" "$FM_CMDFILE" \
						> "$FM_CMDFILE.backup" \
						&& cp "$FM_CMDFILE.backup" "$FM_CMDFILE" ;;
				*)
					ExecCMD=$(printf '%s' "$cmdmenu" \
						| awk -F ' - ' '{print $1}')
					if printf '%s' "$ExecCMD" | grep '\$'; then
						AllowBulk='Bulk Execute'
						AllSelection='Bulk Execute all'
						GenActMenu "Choose and execute: " "$FMActionColorLV1"
						if [ -n "$bulkselection" ]; then
							BulkMode 'Select to execute: '
							BulkCMD
						elif [ "$ActChoice" = "$AllSelection" ]; then
							BulkAllList
							BulkCMD
						else
							SELECTED=$Here
							BulkCMD
						fi
					else
						ExecuteCMD "$ExecCMD"
					fi ;;
			esac ;;
	esac

	MainMenu
}

### MAIN FUNCTIONS

MainMenu () {
	while [ -n "$Choice" ]; do
		UpdateMenu
		# Default menu list if no arguments given
		if [ -z "$KeepList" ]; then
			menu && list="$DIRs$FILEs$DOTDIRs$DOTFILEs"
		fi

		# Generate menu with/without arguments
		# Show only the current directory and one level of parent directory
		TwoPWD=$(printf '%s' "$PWD" | awk -F '/' '{print $(NF-1)"/"$NF}')

		Choice=$(
			printf '%s:' "$BACKWARD" "$TARGET" "$ACTION" "$TERM" "$list"\
				| tr ':' '\n' | sed "/^$/ d" | yprompt "$TwoPWD" "$FMGenericColor"
		)

		# Outcome matching
		if [ "$Choice" = "$TARGET" ]; then
			FileOpen "$PWD"
		elif [ "$Choice" = "$BACKWARD" ]; then
			cd "../"
			dmenufm_history
		elif [ "$Choice" = "$ACTION" ]; then
			dmenufm_action
		elif [ "$Choice" = "$TERM" ]; then
			$TERMINAL
		elif [ -d "$Choice" ]; then
			cd "$Choice" || exit 1
			dmenufm_history
			continue
		elif [ -f "$Choice" ]; then
			FileOpen "$PWD/$Choice"
		else
			break
		fi
	done
}

### ARGUMENTS

while [ -n "$1" ]; do
	case $1 in
		-d|--directory )
			KeepList="${KeepList} DIRs"
			;;
		-f|--file )
			KeepList="${KeepList} FILEs"
			;;
		-D|--dotdirectory )
			KeepList="${KeepList} DOTDIRs"
			;;
		-F|--dotfile )
			KeepList="${KeepList} DOTFILEs"
			;;
		-p|--lastpath )
			OutputPath="placeholder"
			;;
		-h|--help )
			printf " Optional arguments for custom usage:
			-d | --directory: only directories
			-f | --file: only show files
			-D | --dotdirectory: only show hidden directories
			-F | --dotfile: only show hidden files
			-p | --lastpath: opens in last working directory (cd on exit)
			-h | --help: Show this message\\n"
			exit 0
			;;
		*)
			if [ -d "$1" ]; then
				cd "$1"
			else
				printf '%s\n' "Invalid option"
				exit 1
			fi
			;;
	esac
	shift
done

### RUN THE MAIN FUNCTION

# --lastpath option:
[ -n "$OutputPath" ] && cd "$(cat -u "$FMLastPath")"

MainMenu

printf '%s' "$PWD" > "$FMLastPath"
